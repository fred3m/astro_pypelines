// _fitting_tools.c
// Interface to connect Astro Pypeline C++ fitting tools functions with Python
// 2014 by Fred Moolekamp

#include "Python.h"
#include "stdio.h"
#include "stdlib.h"
#include "numpy/arrayobject.h"
#include "fitting_tools.h"
#include "mpfit.h"

/* ==== Allocate a double *vector (vec of pointers) ======================
     Memory is Allocated!  See void free_Carray(double ** )                  */
// Taken from Scipy Cookbook: http://wiki.scipy.org/Cookbook/C_Extensions/NumPy_arrays
double **ptrvector(long n)  {
    double **v;
    v=(double **)malloc((size_t) (n*sizeof(double)));
    if (!v)   {
        printf("In **ptrvector. Allocation of memory for double array failed.");
        exit(0);
    };
    return v;
};

// Taken from Scipy Cookbook: http://wiki.scipy.org/Cookbook/C_Extensions/NumPy_arrays
double *nparray_to_double_2Darray(PyArrayObject *arrayin){
    double **c, *a;
    int n,m;
    n = arrayin->dimensions[0];
    m = arrayin->dimensions[1];
    c = ptrvector(n);
    a = (double *) arrayin->data;
    for(int i=0; i<n; i++){
        c[i]=a+i+m;
    };
    return c;
};

// Taken from Scipy Cookbook: http://wiki.scipy.org/Cookbook/C_Extensions/NumPy_arrays
int *nparray_to_int_array(PyArrayObject *arrayin){
    int i,n;
    n=arrayin->dimensions[0];
    return (int *) arrayin->data;
};

static PyObject* fitting_tools_fit_elliptical_moffat(PyObject *self, PyObject *args){
    // variables from python
    PyArrayObject *img_data_py, *x_cm_py, *y_cm_py;
    double **img_data, *x_cm, *y_cm;
    int aperture_radius;
    double threshold;
    
    double **objects;
    
    // local image variable
    double *local_data;
    int *x;
    int *y;
    int img_data_height, img_data_width, nbr_objs, x0, xf, y0, yf;
    int local_width, local_height, aperture_width, allocated_width, allocated_height;
    double local_min, local_max;
    
    // mpfit variables
    int status;
    double params[8];
    mp_result result;
    memset(&result,0,sizeof(result));       /* Zero results structure */
    
    // return array variables
    
    objects = malloc(nbr_objs * sizeof(double *));
    for (i = 0; i < rows; i++)
      objects[i] = malloc(10 * sizeof(double));
    
    printf("Variables loaded");
    
    // Load parameters from python
    if(!PyArg_ParseTuple(args,"O!O!O!id",&PyArray_Type, &img_data_py,
                &PyArray_Type, &x_cm_py, &PyArray_Type, &y_cm_py, &aperture_radius, &threshold)){
        return NULL;
    };
    
    if (NULL == img_data) return NULL;
    if (NULL == x_cm) return NULL;
    if (NULL == y_cm) return NULL;
    
    printf("Sucessfully loaded parameters");
    
    // Allocate memory for the array pointers
    // This will be reallocated for each 
    aperture_width = 2*aperture_radius+1;
    local_data = (double *) malloc(aperture_width*aperture_width*sizeof(double));
    x = (int *) malloc(aperture_width*sizeof(int *));
    y = (int *) malloc(aperture_width*sizeof(int *));
    allocated_width = aperture_width;
    allocated_height = aperture_width;
    
    printf("Successfully allocated memory");
    
    img_data = nparray_to_double_2Darray(img_data_py);
    x_cm = nparray_to_int_array(x_cm_py);
    y_cm = nparray_to_int_array(y_cm_py);
    
    printf("Successfully converted numpy to c arrays");
    
    img_data_width = img_data_py->dimensions[0];
    img_data_height = img_data_py->dimensions[1];
    nbr_objs = x_cm_py->dimensions[0];
    
    printf("Starting Loop");
    
    // perform fitting for each object
    //for(int i=0; i<nbr_objs; i++){
    for(int i=0; i<5; i++){
        printf('i=%d', i);
        // Find the bounds of the local data to fit
        if(x_cm[i] > aperture_radius){
            x0=x_cm[i]-aperture_radius;
        } else {
            x0=0;
        };
        if(y_cm[i] > aperture_radius){
            y0=y_cm[i]-aperture_radius;
        } else{
            y0=0;
        };
        if(x_cm[i]+aperture_radius < img_data_width){
            xf = x_cm[i]+aperture_radius;
        } else {
            xf = img_data_width;
        };
        if(y_cm[i]+aperture_radius < img_data_height){
            yf = y_cm[i]+aperture_radius;
        } else {
            yf = img_data_height;
        };
        
        // Build x and y axes of the local image and
        // reallocate memory (if necessary)
        local_width = xf-x0;
        local_height = yf-y0;
        if(allocated_width != local_width){
            x = realloc(x, local_width*sizeof(int *));
        };
        if(allocated_height != local_height){
            y = realloc(y, local_height*sizeof(int *));
        };
        for(int n=0; n<local_width; n++){
            x[n] = x0+n;
        };
        for(int n=0; n<local_height; n++){
            y[n] = y0+n;
        };
        
        // Build the local data array
        if(allocated_width*allocated_height != local_width*local_height){
            local_data = realloc(local_data, local_width*local_height*sizeof(double));
        };
        for(int n=0; n<local_height; n++){
            for(int m=0; m<local_width; m++){
                local_data[n*local_width+m] = img_data[n][m];
            };
        };
        
        allocated_width = local_width;
        allocated_height = local_height;
        
        local_min = local_data[0];
        local_max = local_data[0];
        for(int n=1; n<local_width*local_height; n++){
            if(local_data[n]<local_min){
                local_min = local_data[n];
            }else if(local_data[n]>local_max){
                local_max = local_data[n];
            };
        };
        params[0] = x_cm[i]; //x_mean
        params[1] = y_cm[i]; // y_mean
        params[2] = 5;   // alpha1
        params[3] = 5;   // alpha2
        params[4] = 3.5; // beta
        params[5] = 0; // angle from x-axis
        params[6] = local_max-local_min; // height
        params[7] = local_min;   // floor
        
        status = elliptical_moffat_fit(&local_data[0], local_width*local_height, 
                &x[0], &y[0], local_width, local_height, params, &result, threshold);
    }
    
    Py_RETURN_TRUE;
};

static PyMethodDef fitting_tools_methods[] = {
	{"fit_elliptical_moffat", fitting_tools_fit_elliptical_moffat, METH_VARARGS},
	{NULL,NULL}
};

void initfitting_tools(){
	(void) Py_InitModule("fitting_tools", fitting_tools_methods);
    import_array();
};

//static PyMethodDef fitting_tools_methods[] = {
//	{"fit_elliptical_moffat",(PyCFunction) fitting_tools_fit_elliptical_moffat, METH_VARARGS,NULL},
//	{NULL,NULL,0,NULL}
//};

//void initfitting_tools(){
//    Py_InitModule3("fitting_tools", fitting_tools_methods,"C functions for Astro Pypeline fitting");
//    import_array();
//}